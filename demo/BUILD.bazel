load("@tx-kit-ext//rules/build:tx_binary.bzl", "tx_binary")
load("@bazel_skylib//rules:copy_directory.bzl", "copy_directory")

tx_binary(
    name = "hello-pkg",
    srcs = glob(["hello-pkg/**"]),
    deps = ["@tx-pkg-aux//src:pkg-boot"],
)

tx_binary(
    name = "hello-coro",
    srcs = glob(["hello-coro/**"]),
    deps = ["@tx-pkg-aux//src:pkg-boot"],
)

tx_binary(
    name = "try-asio",
    srcs = glob(["try-asio/**"]),
    deps = [
        "@tx-pkg-aux//src:pkg-boot",
        "@asio//:asio",
    ],
)

tx_binary(
    name = "try-sdl3-1st",
    srcs = glob(["try-sdl3-1st/**"]),
    deps = [
        "@tx-pkg-aux//src:pkg-boot",
        "@sdl3//:sdl3_static",
    ],
    #TODO: add support for sdl3_shared build on platforms except wasm32
    # + select({
    #     "@platforms//cpu:wasm32": ["@sdl3//:sdl3_static"],
    #     "//conditions:default": ["@sdl3//:sdl3_shared"],
    # }),
)

copy_directory(
    name = "copy_data",
    src = "try-sdl3-2nd/data",
    out = "data",
)
tx_binary(
    name = "try-sdl3-2nd",
    srcs = glob(["try-sdl3-2nd/*.cpp"]),
    data = [
        ":copy_data",
    ],
    deps = [
        "@tx-pkg-aux//src:pkg-boot",
        "@sdl3//:sdl3_static",
    ],
    linkopts = select({
        "//conditions:default": [],
        "@platforms//cpu:wasm32": [
            "--preload-file", "$(location :copy_data)@/data",
        ],
    }),
)

#DISABLED because current SDL3pp version has issues with constexpr, exceptions and another compile errors w/ clang and C++20
# tx_binary(
#     name = "try-sdl3pp-1st",
#     srcs = glob(["try-sdl3pp-1st/**"]),
#     deps = [
#         "@tx-pkg-aux//src:pkg-boot",
#         "@sdl3pp//:sdl3pp_headers",
#         "@sdl3//:sdl3_static",
#     ],
#     cxxopts = [
#         "-Wno-invalid-constexpr",
#         "-Wno-mismatched-tags",
#         "-Wno-unused-variable",
#         "-Wno-missing-braces",
#         "-fexceptions",
#     ],
# )

tx_binary(
    name = "try-nghttp2",
    srcs = glob(["try-nghttp2/**"]),
    deps = [
        "@tx-pkg-aux//src:pkg-boot",
        "@nghttp2//:nghttp2",
        "@openssl//:crypto",
        "@openssl//:ssl",
    ],
    target_compatible_with = select({
        "@platforms//cpu:wasm32": ["@platforms//:incompatible"],
        "//conditions:default": [],
    }),
)

tx_binary(
    name = "try-wasm-fetch",
    srcs = glob(["try-wasm-fetch/**"]),
    deps = [
        "@tx-pkg-aux//src:pkg-boot",
    ],
    linkopts = [
        "-sFETCH=1",
        "-sASYNCIFY",
        "--post-js", "$(location :try_wasm_fetch_post_js)",
    ],
    data = [
        ":try_wasm_fetch_post_js",
    ],
    target_compatible_with = select({
        "@platforms//cpu:wasm32": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
)

# Post-JS file to polyfill fetch/XMLHttpRequest for Node.js and detect runtime
genrule(
    name = "try_wasm_fetch_post_js",
    outs = ["try_wasm_fetch_post.js"],
    cmd = """cat > $@ << 'EOF'
// Detect runtime environment and set global flag
if (typeof Module !== 'undefined') {
  Module.__EMSCRIPTEN_IS_BROWSER__ = typeof window !== 'undefined' && typeof navigator !== 'undefined';
}

// Polyfill for XMLHttpRequest in Node.js using native fetch
if (typeof XMLHttpRequest === 'undefined' && typeof global !== 'undefined') {
  global.XMLHttpRequest = function() {
    this.responseText = '';
    this.response = null;
    this.status = 0;
    this.statusText = '';
    this.readyState = 0;
    this.onreadystatechange = null;
    this.onload = null;
    this.onerror = null;
    this.ontimeout = null;
    this.timeout = 0;
  };
  
  global.XMLHttpRequest.prototype.open = function(method, url, async) {
    this.method = method;
    this.url = url;
    this.async = async !== false;
  };
  
  global.XMLHttpRequest.prototype.send = function(data) {
    const self = this;
    const url = this.url;
    const method = this.method || 'GET';
    
    // Use native Node.js fetch (available in Node 18+) or require node-fetch
    let fetchFunc;
    if (typeof fetch !== 'undefined') {
      fetchFunc = fetch;
    } else {
      try {
        const fetch = require('node-fetch');
        fetchFunc = fetch;
      } catch (e) {
        console.error('node-fetch not available');
        return;
      }
    }
    
    const fetchOptions = {
      method: method,
      headers: {}
    };
    
    fetchFunc(url, fetchOptions)
      .then(res => {
        self.status = res.status;
        self.statusText = res.statusText;
        self.readyState = 4;
        return res.arrayBuffer();
      })
      .then(buffer => {
        // Store as ArrayBuffer, Emscripten will extract numBytes from it
        self.response = buffer;
        self.responseText = new TextDecoder().decode(buffer);
        if (self.onload) {
          self.onload();
        }
        if (self.onreadystatechange && runtimeKeepaliveCounter > 0) {
          self.onreadystatechange();
        }
      })
      .catch(err => {
        self.status = 0;
        self.readyState = 4;
        if (self.onerror) {
          self.onerror(err);
        }
        if (self.onreadystatechange && runtimeKeepaliveCounter > 0) {
            self.onreadystatechange();
        }
      });
  };
}
EOF
""",
)
